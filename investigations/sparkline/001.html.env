<html>
<p>
Example of Sparkline component.
</p>
<script crossorigin 
  src="https://unpkg.com/react@16/umd/react.development.js">
</script>
<script crossorigin 
  src="https://unpkg.com/react-dom@16/umd/react-dom.development.js">
</script>
<script crossorigin
  src="https://unpkg.com/d3@3.5.9/d3.js">
</script>
<script crossorigin 
  src="https://unpkg.com/babel-standalone@6.26.0/babel.js">
</script>

<!-- Following from: https://reactjs.org/docs/state-and-lifecycle.html -->

<p>Sparkline ver $SPARKLINE_VER </p>

<div id="root"></div>
<script type="text/babel">

// DEPENDENCIES
const {
    useState,
    useEffect,
    useReducer,
    useCallback,
    useMemo,
    createContext,
    useContext 
} = React;

const { 
    range, 
    select,
    scaleLinear 
} = d3;

const { render } = ReactDOM;

const DATA_SERVER_URL = "http://165.227.30.170:$HTTP_PORT/json";

// DEBUG
// localStorage.clear();


// MODEL

// MODEL INIT
if (localStorage.getItem("model") !== null) {
    console.log("hello")
    setModel({...getModel()});
}

if (localStorage.getItem("model") === null) {
    setObject("model",
        { 
            isStreamOn: false,
            data: [],
            number: 0
        }
    );
}


const MOUNT_POINT = document.getElementById("root");

function updateView() {
    return () => render(
        <Provider>
            <Display />
            <ControllerDisplay />
        </Provider>,
        MOUNT_POINT 
    );
}

function getObject(key) {
    return JSON.parse(localStorage.getItem(key));
}

function setObject(key, obj) {
    localStorage.setItem(key, JSON.stringify(obj))
    return obj;
}

function getModel() {
    return getObject("model");
}

function setModel(obj) {
    setObject("model", obj);
    updateView();
    return;
}

const ACTION = {};

function reducer(state = getModel(), action) {
    switch(action.type) {
        case "GET_DATA":
            setModel({
                ...state,
                data: [...state.data, action.payload]
            });
            return getModel();
        case "INCREMENT": 
            setModel({
                ...state,
                data: [
                    ...state.data,
                    state.number
                ],
                number: state.number + 1
            });
            console.log(getModel());
            return getModel();
            //return { ...state, number: state.number + 1};
        case "TOGGLE_STREAM":
            setModel({...state, isStreamOn: !state.isStreamOn});
            return getModel();
            //return { ...state, isStreamOn: !state.isStreamOn };
        default:
            return state    
    }
}

// END OF MODEL


/* I think there would be a dispatchProvider and a stateProvider */

// https://kentcdodds.com/blog/how-to-use-react-context-effectively
// https://aheadcreative.co.uk/articles/learning-react-context-api/

//CONTROLLERS

function asyncer(dispatch, state) {
    return function(action) {
        typeof action === "function" ? 
            action(dispatch, state) : 
            dispatch(action)
    }
}

const GlobalStore = createContext();

function handleGetData(dispatch, state) {
        console.log("handleGetData");
        console.log("dispatch: ", dispatch);
        console.log("state", state);
        fetch(DATA_SERVER_URL)
            .then(handleErrors)
            .then(response => response.json())
            .then(function(response) {
                console.log("response json: ", response);
                dispatch({
                    type: "GET_DATA", 
                    payload: response
                });
            })
            .catch(error => console.log(error))
}

/* building up to this
function handleGetData(url, dispatch) {
    fetch(url)
        .then(handleErrors)
        .then(response => response.json)
        .then(function(response) {
            console.log("the response: ", response)
            dispatch({ type: "GET_DATA", payload: response.data });
        }).catch(error => dispatch({ type: "ERROR", payload: "Error" }));

    const model = getObject("model");
    if (model.isStreamOn) { 
        fetch(url)
            .then(handleErrors)
            .then(response => response.json())
            .then(function(response) {
                dispatch({ type: "GET_DATA", payload: response });
            })
            .catch(function(error) {
                dispatch({ type: "ERROR", payload: "An error has occurred" });
            })
    }
}
*/


function useGlobalStore() {
    const context = useContext(GlobalStore);
    if (context === undefined) {
        throw new Error("Error thrown");
    }
    /* context: { view, dispatch } */
    return context;
}
// END OF CONTROLLERS


// VIEW
function Provider({ children }) {
    const [ state, dispatch ] = useReducer(reducer, getObject("model"));

    const actionHandler = asyncer(dispatch, state);
    const dispatchActionOrType = useCallback(actionHandler, []);

    const value = useMemo(() => ({
        view: state,
        dispatch: dispatchActionOrType
    }));

    console.log("Provider has mounted");
    return (
        <GlobalStore.Provider value={value}>
            {children}
        </GlobalStore.Provider>
    );
}

function Node(props) {
    return <span> {props.data} </span>;
}

function createGraphNode(json, i) {
    const { data, id, type } = json;
    return <Node data={data} key={id} />;
}

function Display() {

    // view.number (going to increment)
    const { view } = useGlobalStore();

    console.log("Display has mounted with view: ");
    console.log(view);

    return (
        <React.Fragment>
            <h1>Graph</h1>
            <div>{view.data.map(createGraphNode)}</div>
        </React.Fragment>
    );
}

function ControllerDisplay() {
    const { dispatch } = useGlobalStore();
    console.log("ControllerDisplay has mounted with dispatch: :");
    console.log(dispatch);

    return (
        <button onClick={() => dispatch(handleGetData)}>
            Click here
        </button>
    );

/*
    return (
        <button onClick={() => dispatch({type: "INCREMENT"})}>
            Click here
        </button>
    );
*/
}

// https://codesandbox.io/s/react-codesandbox-je6cc?file=/src/count.js

render(
    <Provider>
        <Display />
        <ControllerDisplay />
    </Provider>,
    MOUNT_POINT
);


function handleErrors(response) {
    if (!response.ok) {
        throw Error(response.statusText);
    }
    return response;
}

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
/*
function App() {
    const [data, setData] = useState(false);
    const [doStream, setDoStream] = useState(model.isStreamOn);

    model.updateViewState = function () {
        console.log("in updateViewState");
        setDoStream(model.isStreamOn);
    };

    useEffect(function() {
        const interval = setInterval(function() {
            //console.log("in interval: model:",model);
            if(model.isStreamOn === true){
                 getData("http://$SPARKLINE_IP:$HTTP_PORT/json",
                     setData, doStream);
             }
             
        },
            1000
        );

        return () => clearInterval(interval);

    }, [])

    return (
        <React.Fragment>
            <View {...data} />
            <button onClick={() => setDoStream(!doStream)}>
                { doStream ? "Turn Off Stream" : "Turn On Stream" }
            </button>
        </React.Fragment>
    );
}

*/
/*
    useEffect(function() {
        if( doStream ) {

            // setInterval will take a function
            const interval = setInterval(function() {
                getData("http://$SPARKLINE_IP:$HTTP_PORT/json", setData);
            },
                1000
            );

            return () => clearInterval(interval);
        }

        if (!doStream) {
            return null;
        }

    }, [])
*/

</script>
</html>
